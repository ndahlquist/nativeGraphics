#include "ParticleSystem.h"
#include "Eigen/Sparse"
#include <cmath>
#include <vector>
#include <list>
using std::list;
using std::vector;

typedef Eigen::SparseMatrix<double,RowMajor> SpMat;

#define Cell_NUM_X 20
#define Cell_NUM_Y 100
#define Cell_NUM_Z 20
#define KCFL 0.9f
#define DIRECTION_X 0
#define DIRECTION_Y 1
#define DIRECTION_Z 2
#define GRAVITY 100.0f
#define FRAME_TIME 0.04f

#define SIZE 100

#define CELL_WIDTH 0.01
#define DIRECTION_X 0
#define DIRECTION_Y 1
#define KCFL 0.9
#define FRAME_TIME 0.002
#define SOLID_WALL 1
#define AIR 3
#define FLUID 4
#define GRAVITY 100
#define i_low 34
#define i_high 68
#define j_low 10
#define j_high 90

Fluid::Fluid(){
	particleRadius=CELL_WIDTH/sqrt(2.0);
	
  memset(u, 0, sizeof(u));
	memset(v, 0, sizeof(v));
	memset(status, 0, sizeof(status));
	memset(newu, 0, sizeof(newu));
	memset(newv, 0, sizeof(newv));
	
  deltaTime=0.0;
  maxVelocity=1.0;
   
}

void Fluid::updateDeltaTime()
{
	deltaTime = KCFL * CELL_WIDTH / maxVelocity;
	if (deltaTime > FRAME_TIME)
	{
		deltaTime = FRAME_TIME;
	}
}


void Fluid::updateCells(){
	unsigned int layer_size = sizeof(layer);
	memset(layer, 0, layer_size);
	for (list<Vector_2D>::iterator iter = listParticles.begin(); iter != listParticles.end();)
	{
		int i = static_cast<int>(floor(iter->x / CELL_WIDTH));
		int j = static_cast<int>(floor(iter->y / CELL_WIDTH));
		if (status[i][j] == SOLID_WALL){
			
			iter = listParticles.erase(iter);
			continue;
		}
		else{
			status[i][j]=FLUID;
			layer[i][j]=1;
		}
		iter++;
	}
	for(int i=0;i<SIZE;i++)
		for(int j=0;j<SIZE;j++){
			if(status[i][j]!=SOLID_WALL&&!layer[i][j]){//·ÇÇ½·ÇÒº£¬¿ÕÆø
					status[i][j]=AIR;
			}
		}
}

Vector_2D Fluid::getVelocity(double x, double y)
{
	Vector_2D w;
	w.x = getInterpolatedValue(x/CELL_WIDTH, y/CELL_WIDTH-0.5 , DIRECTION_X);
	w.y = getInterpolatedValue(x/CELL_WIDTH-0.5, y/CELL_WIDTH , DIRECTION_Y);
	return w;
	
}

double Fluid::getInterpolatedValue(double x, double y, int direction)
{
    int i = static_cast<int>(floor(x));
	int j = static_cast<int>(floor(y));
	
	double weight = 0.0;
	double sum = 0.0;
	switch(direction)
	{
	case DIRECTION_X:
		if (status[i][j]!= SOLID_WALL)
		{
			sum += (i + 1 - x) * (j + 1 - y) * u[i][j];
			weight += (i + 1 - x) * (j + 1 - y);
		}
		if (status[i + 1][j] != SOLID_WALL)
		{
			sum += (x - i) * (j + 1 - y)  * u[i + 1][j];
			weight += (x - i) * (j + 1 - y);
		}
		if (status[i][j + 1] != SOLID_WALL)
		{
			sum += (i + 1 - x) * (y - j) * u[i][j + 1];
			weight += (i + 1 - x) * (y - j);
		}
		if (status[i + 1][j + 1]!= SOLID_WALL)
		{
			sum += (x - i) * (y - j) * u[i + 1][j + 1];
			weight += (x - i) * (y - j) ;
		}
        if (weight == 0.)
            return 0.;
        else
		    return sum / weight;
		break;
	case DIRECTION_Y:
		if (status[i][j]!= SOLID_WALL)
		{
			sum += (i + 1 - x) * (j + 1 - y) * v[i][j];
			weight += (i + 1 - x) * (j + 1 - y);
		}
		if (status[i + 1][j] != SOLID_WALL)
		{
			sum += (x - i) * (j + 1 - y) * v[i + 1][j];
			weight += (x - i) * (j + 1 - y);
		}
		if (status[i][j + 1] != SOLID_WALL)
		{
			sum += (i + 1 - x) * (y - j) * v[i][j + 1];
			weight += (i + 1 - x) * (y - j);
		}
		if (status[i + 1][j + 1] != SOLID_WALL)
		{
			sum += (x - i) * (y - j)  * v[i + 1][j + 1];
			weight += (x - i) * (y - j);
		}
        if(weight == 0.)
            return 0.;
        else
		    return sum / weight;
		break;
	default:
		return 0;
	}
}


Vector_2D Fluid::traceParticle(double x, double y, double t)
{
	Vector_2D w = getVelocity(x, y);
    w = getVelocity(x - 0.5 * t * w.x, y - 0.5 * t * w.y);
	return Vector_2D(x,y) - w * t;
}

void Fluid::advection(){
	unsigned int u_size = sizeof(u),v_size = sizeof(v);
	memset(newu, 0, u_size);
	memset(newv, 0, v_size);//Initialization is important to avoid unexpected data input
	for (int i=0;i<SIZE;i++)
		for (int j=0;j<SIZE;j++){
			
			if(status[i][j]==FLUID){
				Vector_2D w;
				w = this->traceParticle(static_cast<double>(i) * CELL_WIDTH, static_cast<double>(j + 0.5) * CELL_WIDTH, this->deltaTime);
				newu[i][j] = this->getVelocity(w.x,w.y).x;
				w = this->traceParticle(static_cast<double>(i+ 0.5) * CELL_WIDTH, static_cast<double>(j) * CELL_WIDTH, this->deltaTime);
				newv[i][j] = this->getVelocity(w.x,w.y).y;
			}
			else {
				if (i>0&&status[i-1][j] == FLUID){
				Vector_2D w;
			    w = this->traceParticle((i+0.) * CELL_WIDTH, (j + 0.5) * CELL_WIDTH, deltaTime);
                    
				newu[i][j] = this->getVelocity(w.x,w.y).x;
				
				}
				if (j>0&&status[i][j-1] == FLUID)
				{
				
				Vector_2D w;
				w = this->traceParticle(static_cast<double>(i + 0.5) * CELL_WIDTH, static_cast<double>(j) * CELL_WIDTH, deltaTime);
				newv[i][j] = this->getVelocity(w.x,w.y).y;
				
				}
			}
	}
    	for (int i=0;i<SIZE;i++)
		for (int j=0;j<SIZE;j++){
			if(status[i][j]!= SOLID_WALL){
				u[i][j]=newu[i][j];
				v[i][j]=newv[i][j];
			}
	}
}

void Fluid::addGravity(){

	for (int j=0;j<SIZE;j++)
		for (int i=0;i<SIZE;i++){
			if(status[i][j]==FLUID)
				v[i][j] -= deltaTime * GRAVITY;
			else if (j>0&&status[i][j-1] == FLUID)
				v[i][j] -= deltaTime * GRAVITY;
		}
}

void Fluid::getPressure(){
	vector<int> index_x;
	vector<int> index_y;
	int posX,posY;
	int fluid_count = 0;
	
  for (int i=0;i<SIZE;i++)
		for (int j=0;j<SIZE;j++){
			if (status[i][j] == FLUID)
			{
				index_x.push_back(i);
				index_y.push_back(j);
				layer[i][j]=fluid_count;
				fluid_count++;
			}
	}

  SpMat P(fluid_count, fluid_count);
  P.reserve(VectorXi::Constant(fluid_count,5));
	int row_index = 0;
  for (int i=0;i<fluid_count;i++){
		int neighbor = 0;

		posX = index_x[i];
		posY = index_y[i];
		
    if (status[posX - 1][posY] == FLUID)
		{
			neighbor++;
      P.insert(row_index,layer[posX-1][posY]) = -1.0;
		}
		else if (status[posX - 1][posY] == AIR)
		{
			neighbor++;
		}

		if (status[posX + 1][posY] == FLUID)
		{
			neighbor++;
      P.insert(row_index,layer[posX+1][posY]) = -1.0;
		}
		else if (status[posX + 1][posY] == AIR)
		{
			neighbor++;
		}

		if (status[posX][posY - 1] == FLUID)
		{
			neighbor++;
      P.insert(row_index,layer[posX][posY-1]) = -1.0;
		}
		else if (status[posX][posY - 1] == AIR)
		{
			neighbor++;
		}

		if (status[posX][posY + 1] == FLUID)
		{
			neighbor++;
      P.insert(row_index,layer[posX][posY+1]) = -1.0;
		}
		else if (status[posX][posY + 1] == AIR)
		{
			neighbor++;
		}
	
    P.insert(row_index,row_index) = (double)neighbor;
      
		row_index++;
	}
	VectorXd x(fluid_count), rhs(fluid_count);
	for (int i = 0; i < fluid_count; i++){
		  posX=index_x[i];
		  posY=index_y[i];
			rhs(i) = -(u[posX+1][posY]-u[posX][posY]+v[posX][posY+1]-v[posX][posY]);
			if ( status[posX-1][posY] == SOLID_WALL)
				rhs(i) -=u[posX][posY];
			if (status[posX+1][posY] == SOLID_WALL)
				rhs(i) +=u[posX+1][posY];

			if (status[posX][posY-1] == SOLID_WALL)
				rhs(i) -=v[posX][posY];
			if (status[posX][posY+1] == SOLID_WALL)
				rhs(i) +=v[posX][posY+1];
	}
  ConjugateGradient<SparseMatrix<double>>	cg;
  cg.compute(P);
  x = cg.solve(rhs);
	for (int i = 0; i != fluid_count; i++)
	{
		posX=index_x[i];
		posY=index_y[i];
		p[posX][posY] = x(i);
	}
	
	maxVelocity = 0.0;
	for (int i=0;i<SIZE;i++)
		for (int j=0;j<SIZE;j++){
			if (status[i][j] == FLUID){
				u[i][j] -= p[i][j];
				u[i+1][j] +=p[i][j];
				v[i][j] -=p[i][j];
				v[i][j+1] +=p[i][j];
				double l = u[i][j]*u[i][j]+v[i][j]*v[i][j];
				if (maxVelocity*maxVelocity < l){
					maxVelocity = sqrt(l);
				}
			}
		}
    for (int i=0;i<SIZE;i++)
		for (int j=0;j<SIZE;j++){
			if (status[i][j] == SOLID_WALL){
				u[i][j]=0;
				u[i+1][j]=0;
				v[i][j]=0;
				v[i][j+1]=0;
			}
		    
	}
}


void Fluid::updateStep(){
	
	updateCells();
	
    advection();		

	addGravity();	

	getPressure();		
		
	moveParticles(deltaTime);
	
}
void Fluid::update(){
	remainderTime=FRAME_TIME;
	while (remainderTime>1e-8){
		    updateDeltaTime();		//1
			remainderTime -= deltaTime;
			if(remainderTime<-1e-8){
				deltaTime = deltaTime+remainderTime;
			    updateStep();
				break;
			}
			else
				updateStep();
	}	
}

void Fluid::moveParticles(float time)
{
	for (list<Vector_2D>::iterator iter = listParticles.begin(); iter != listParticles.end();iter++)
	{
		Vector_2D before = *iter;
		Vector_2D start_velocity = getVelocity(before.x,before.y);
		Vector_2D midpoint = before + start_velocity*0.5f*time;
		Vector_2D mid_velocity = getVelocity(midpoint.x,midpoint.y);
		*iter += mid_velocity * time;
	}

}
/*
//is in the simulation bound
bool ParticleSystem::isInBound(Cell *pCell)
{
	if (pCell->x >= 0 && pCell->x < Cell_NUM_X
		&& pCell->y >= 0 && pCell->y < Cell_NUM_Y
		&& pCell->z >= 0 && pCell->z < Cell_NUM_Z)
	{
		return true;
	}
	else
	{
		return false;
	}
}

//set the cell to be buffer cell
void ParticleSystem::CreateBuffer(Cell *N, int i)
{
	if (N->status != NOTHING)
	{
		if (N->layer == -1 && N->status != SOLID)
		{
			N->status = AIR;
			N->layer = i;
		}
		//In the paper this part is missing
		else if (N->layer == -1 && N->status == SOLID)
		{
			N->layer = i;
		}
		//////////////////////////////////////////////
	}
	else
	{
		N->layer = i;
		listCells.push_back(N);
		if (isInBound(N))
		{
			N->status = AIR;
		}
		else
		{
			N->status = SOLID;
		}
	}
}

//get the cell at a certain position
Cell *ParticleSystem::getCell(Vector &pos)
{
	int i = static_cast<int>(floor(pos.x / CELL_WIDTH));
	int j = static_cast<int>(floor(pos.y / CELL_WIDTH));
	int k = static_cast<int>(floor(pos.z / CELL_WIDTH));
	grid[BUFFER + i][BUFFER + j][BUFFER + k].x = i;
	grid[BUFFER + i][BUFFER + j][BUFFER + k].y = j;
	grid[BUFFER + i][BUFFER + j][BUFFER + k].z = k;
	return &grid[BUFFER + i][BUFFER + j][BUFFER + k];
}

//trace a particle at a point(x,y,z) for t time
Vector ParticleSystem::traceParticle(float x, float y, float z, float t)
{
	Vector v = getVelocity(x, y, z);
	v = getVelocity(x + 0.5f * t * v.x, y + 0.5f * t * v.y, z + 0.5f * t * v.z);
	return Vector(x, y, z) + v * t;
}

//get the velocity at position(x,y,z)
Vector ParticleSystem::getVelocity(float x, float y, float z)
{
	Vector v;
	v.x = getInterpolatedValue(x / CELL_WIDTH, y / CELL_WIDTH - 0.5f, z / CELL_WIDTH - 0.5f, DIRECTION_X); 
	v.y = getInterpolatedValue(x / CELL_WIDTH - 0.5f, y / CELL_WIDTH, z / CELL_WIDTH - 0.5f, DIRECTION_Y);
	v.z = getInterpolatedValue(x / CELL_WIDTH - 0.5f, y / CELL_WIDTH - 0.5f, z / CELL_WIDTH, DIRECTION_Z);
	return v;
}

//get an interpolated value from the grid
float ParticleSystem::getInterpolatedValue(float x, float y, float z, int direction)
{
	int i = static_cast<int>(floor(x));
	int j = static_cast<int>(floor(y));
	int k = static_cast<int>(floor(z));
	float weight = 0.0f;
	float sum = 0.0f;
	switch(direction)
	{
	case DIRECTION_X:
		if (grid[BUFFER + i][BUFFER + j][BUFFER + k].status != NOTHING)
		{
			sum += (i + 1 - x) * (j + 1 - y) * (k + 1 - z) * grid[BUFFER + i][BUFFER + j][BUFFER + k].velocity.x;
			weight += (i + 1 - x) * (j + 1 - y) * (k + 1 - z);
		}
		if (grid[BUFFER + i + 1][BUFFER + j][BUFFER + k].status != NOTHING)
		{
			sum += (x - i) * (j + 1 - y) * (k + 1 - z) * grid[BUFFER + i + 1][BUFFER + j][BUFFER + k].velocity.x;
			weight += (x - i) * (j + 1 - y) * (k + 1 - z);
		}
		if (grid[BUFFER + i][BUFFER + j + 1][BUFFER + k].status != NOTHING)
		{
			sum += (i + 1 - x) * (y - j) * (k + 1 - z) * grid[BUFFER + i][BUFFER + j + 1][BUFFER + k].velocity.x;
			weight += (i + 1 - x) * (y - j) * (k + 1 - z);
		}
		if (grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k].status != NOTHING)
		{
			sum += (x - i) * (y - j) * (k + 1 - z) * grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k].velocity.x;
			weight += (x - i) * (y - j) * (k + 1 - z);
		}
		if (grid[BUFFER + i][BUFFER + j][BUFFER + k + 1].status != NOTHING)
		{
			sum += (i + 1 - x) * (j + 1 - y) * (z - k) * grid[BUFFER + i][BUFFER + j][BUFFER + k + 1].velocity.x;
			weight += (i + 1 - x) * (j + 1 - y) * (z - k);
		}
		if (grid[BUFFER + i + 1][BUFFER + j][BUFFER + k + 1].status != NOTHING)
		{
			sum += (x - i) * (j + 1 - y) * (z - k) * grid[BUFFER + i + 1][BUFFER + j][BUFFER + k + 1].velocity.x;
			weight += (x - i) * (j + 1 - y) * (z - k);
		}
		if (grid[BUFFER + i][BUFFER + j + 1][BUFFER + k + 1].status != NOTHING)
		{
			sum += (i + 1 - x) * (y - j) * (z - k) * grid[BUFFER + i][BUFFER + j + 1][BUFFER + k + 1].velocity.x;
			weight += (i + 1 - x) * (y - j) * (z - k);
		}
		if (grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k + 1].status != NOTHING)
		{
			sum += (x - i) * (y - j) * (z - k) * grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k + 1].velocity.x;
			weight += (x - i) * (y - j) * (z - k);
		}
		return sum / weight;
		break;
	case DIRECTION_Y:
		if (grid[BUFFER + i][BUFFER + j][BUFFER + k].status != NOTHING)
		{
			sum += (i + 1 - x) * (j + 1 - y) * (k + 1 - z) * grid[BUFFER + i][BUFFER + j][BUFFER + k].velocity.y;
			weight += (i + 1 - x) * (j + 1 - y) * (k + 1 - z);
		}
		if (grid[BUFFER + i + 1][BUFFER + j][BUFFER + k].status != NOTHING)
		{
			sum += (x - i) * (j + 1 - y) * (k + 1 - z) * grid[BUFFER + i + 1][BUFFER + j][BUFFER + k].velocity.y;
			weight += (x - i) * (j + 1 - y) * (k + 1 - z);
		}
		if (grid[BUFFER + i][BUFFER + j + 1][BUFFER + k].status != NOTHING)
		{
			sum += (i + 1 - x) * (y - j) * (k + 1 - z) * grid[BUFFER + i][BUFFER + j + 1][BUFFER + k].velocity.y;
			weight += (i + 1 - x) * (y - j) * (k + 1 - z);
		}
		if (grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k].status != NOTHING)
		{
			sum += (x - i) * (y - j) * (k + 1 - z) * grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k].velocity.y;
			weight += (x - i) * (y - j) * (k + 1 - z);
		}
		if (grid[BUFFER + i][BUFFER + j][BUFFER + k + 1].status != NOTHING)
		{
			sum += (i + 1 - x) * (j + 1 - y) * (z - k) * grid[BUFFER + i][BUFFER + j][BUFFER + k + 1].velocity.y;
			weight += (i + 1 - x) * (j + 1 - y) * (z - k);
		}
		if (grid[BUFFER + i + 1][BUFFER + j][BUFFER + k + 1].status != NOTHING)
		{
			sum += (x - i) * (j + 1 - y) * (z - k) * grid[BUFFER + i + 1][BUFFER + j][BUFFER + k + 1].velocity.y;
			weight += (x - i) * (j + 1 - y) * (z - k);
		}
		if (grid[BUFFER + i][BUFFER + j + 1][BUFFER + k + 1].status != NOTHING)
		{
			sum += (i + 1 - x) * (y - j) * (z - k) * grid[BUFFER + i][BUFFER + j + 1][BUFFER + k + 1].velocity.y;
			weight += (i + 1 - x) * (y - j) * (z - k);
		}
		if (grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k + 1].status != NOTHING)
		{
			sum += (x - i) * (y - j) * (z - k) * grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k + 1].velocity.y;
			weight += (x - i) * (y - j) * (z - k);
		}
		return sum / weight;
		break;
	case DIRECTION_Z:
		if (grid[BUFFER + i][BUFFER + j][BUFFER + k].status != NOTHING)
		{
			sum += (i + 1 - x) * (j + 1 - y) * (k + 1 - z) * grid[BUFFER + i][BUFFER + j][BUFFER + k].velocity.z;
			weight += (i + 1 - x) * (j + 1 - y) * (k + 1 - z);
		}
		if (grid[BUFFER + i + 1][BUFFER + j][BUFFER + k].status != NOTHING)
		{
			sum += (x - i) * (j + 1 - y) * (k + 1 - z) * grid[BUFFER + i + 1][BUFFER + j][BUFFER + k].velocity.z;
			weight += (x - i) * (j + 1 - y) * (k + 1 - z);
		}
		if (grid[BUFFER + i][BUFFER + j + 1][BUFFER + k].status != NOTHING)
		{
			sum += (i + 1 - x) * (y - j) * (k + 1 - z) * grid[BUFFER + i][BUFFER + j + 1][BUFFER + k].velocity.z;
			weight += (i + 1 - x) * (y - j) * (k + 1 - z);
		}
		if (grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k].status != NOTHING)
		{
			sum += (x - i) * (y - j) * (k + 1 - z) * grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k].velocity.z;
			weight += (x - i) * (y - j) * (k + 1 - z);
		}
		if (grid[BUFFER + i][BUFFER + j][BUFFER + k + 1].status != NOTHING)
		{
			sum += (i + 1 - x) * (j + 1 - y) * (z - k) * grid[BUFFER + i][BUFFER + j][BUFFER + k + 1].velocity.z;
			weight += (i + 1 - x) * (j + 1 - y) * (z - k);
		}
		if (grid[BUFFER + i + 1][BUFFER + j][BUFFER + k + 1].status != NOTHING)
		{
			sum += (x - i) * (j + 1 - y) * (z - k) * grid[BUFFER + i + 1][BUFFER + j][BUFFER + k + 1].velocity.z;
			weight += (x - i) * (j + 1 - y) * (z - k);
		}
		if (grid[BUFFER + i][BUFFER + j + 1][BUFFER + k + 1].status != NOTHING)
		{
			sum += (i + 1 - x) * (y - j) * (z - k) * grid[BUFFER + i][BUFFER + j + 1][BUFFER + k + 1].velocity.z;
			weight += (i + 1 - x) * (y - j) * (z - k);
		}
		if (grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k + 1].status != NOTHING)
		{
			sum += (x - i) * (y - j) * (z - k) * grid[BUFFER + i + 1][BUFFER + j + 1][BUFFER + k + 1].velocity.z;
			weight += (x - i) * (y - j) * (z - k);
		}
		return sum / weight;
		break;
	default:
		return 0;
	}
}

//calculate the divergence of velocity at the centre of a cell
float ParticleSystem::divVelocity(Cell *g) 
{
	int posX = BUFFER + g->x;
	int posY = BUFFER + g->y;
	int posZ = BUFFER + g->z;
	float ret = 0.0f;
	if (grid[posX - 1][posY][posZ].status != SOLID)
	{
		ret += - g->velocity.x;
	}

	if (grid[posX][posY - 1][posZ].status != SOLID)
	{
		ret += - g->velocity.y;
	}

	if (grid[posX][posY][posZ - 1].status != SOLID)
	{
		ret += - g->velocity.z;
	}

	if (grid[posX+1][posY][posZ].status != SOLID)
	{
		ret += grid[posX+1][posY][posZ].velocity.x;
	}
	

	if (grid[posX][posY+1][posZ].status != SOLID)
	{
		ret += grid[posX][posY+1][posZ].velocity.y;
	}
	

	if (grid[posX][posY][posZ+1].status != SOLID)
	{
		ret += grid[posX][posY][posZ+1].velocity.z;
	}
	
	
	return ret;
}

//calculate the gradient of pressure at the center of the cell
Vector ParticleSystem::gradPressure(Cell *C)
{
	Vector v(0.0f, 0.0f, 0.0f);
	int posX = BUFFER + C->x;
	int posY = BUFFER + C->y;
	int posZ = BUFFER + C->z;
	if (grid[posX - 1][posY][posZ].status == AIR)
	{
		v.x = C->pressure;
	}
	else if (grid[posX - 1][posY][posZ].status == FLUID)
	{
		v.x = C->pressure - grid[posX - 1][posY][posZ].pressure;
	}
	if (grid[posX][posY - 1][posZ].status == AIR)
	{
		v.y = C->pressure;
	}
	else if (grid[posX][posY - 1][posZ].status == FLUID)
	{
		v.y = C->pressure - grid[posX][posY - 1][posZ].pressure;
	}
	if (grid[posX][posY][posZ - 1].status == AIR)
	{
		v.z = C->pressure;
	}
	else if (grid[posX][posY][posZ - 1].status == FLUID)
	{
		v.z = C->pressure - grid[posX][posY][posZ - 1].pressure;
	}

	return v;
}

//update the status of fluid
void ParticleSystem::Update()
{
	if (remainderTime >= FRAME_TIME)
	{
		remainderTime -= FRAME_TIME;
		MoveParticles(FRAME_TIME);
	}
	else
	{
		while (remainderTime < FRAME_TIME)
		{
			UpdateDeltaTime();		//1
			MoveParticles(deltaTime);
			//UpdateSolid();
			UpdateCells();			//2
			ApplyConvection();		//3a
			ApplyGravity();			//3b
			ApplyPressure();		//3de
			UpdateBufferVelocity();	//3f
			SetSolidCells();		//3g
			remainderTime += deltaTime;
		}
		remainderTime -= FRAME_TIME;
		MoveParticles(- remainderTime + deltaTime);
	}
}

//calculate the simulation time step
void ParticleSystem::UpdateDeltaTime()
{
	deltaTime = KCFL * CELL_WIDTH / maxVelocity;
	if (deltaTime > FRAME_TIME)
	{
		deltaTime = FRAME_TIME;
	}
}

//calculate the new status of solid
void ParticleSystem::UpdateSolid()
{
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *C = *iter;
		if (C->status == SOLID)
		{
			if (isInBound(C) == true)
			{
				C->status = AIR;
			}
		}
	}
	float corner[8][3];
	for (vector<MyBox>::iterator iter = BoxList.begin(); iter != BoxList.end(); iter++)
	{
		ODEGetBoxVertex(*iter, &corner[0][0]);
		Vector step1(corner[1][0] - corner[0][0], corner[1][1] - corner[0][1], corner[1][2] - corner[0][2]);
		Vector step2(corner[3][0] - corner[0][0], corner[3][1] - corner[0][1], corner[3][2] - corner[0][2]);
		Vector step3(corner[4][0] - corner[0][0], corner[4][1] - corner[0][1], corner[4][2] - corner[0][2]);
		float l1 = step1.length();
		float l2 = step2.length();
		float l3 = step3.length();
		step1 /= l1;
		step2 /= l2;
		step3 /= l3;
		Vector v0(corner[0][0], corner[0][1], corner[0][2]);
		Vector v4(corner[4][0], corner[4][1], corner[4][2]);
		Vector v3(corner[3][0], corner[3][1], corner[3][2]);
		Vector v1(corner[1][0], corner[1][1], corner[1][2]);

		for (Vector i; i.length() <= l1; i += step1)
			for (Vector j; j.length() <= l2; j += step2)
			{
				Cell *C = getCell(v0 + i + j);
				if (C->status == NOTHING)
				{
					listCells.push_back(C);
				}
				C->status = SOLID;
			}

		for (Vector i; i.length() <= l1; i += step1)
			for (Vector j; j.length() <= l2; j += step2)
			{
				Cell *C = getCell(v4 + i + j);
				if (C->status == NOTHING)
				{
					listCells.push_back(C);
				}
				C->status = SOLID;
			}

		for (Vector i; i.length() <= l1; i += step1)
			for (Vector j; j.length() <= l3; j += step3)
			{
				Cell *C = getCell(v0 + i + j);
				if (C->status == NOTHING)
				{
					listCells.push_back(C);
				}
				C->status = SOLID;
			}

		for (Vector i; i.length() <= l1; i += step1)
			for (Vector j; j.length() <= l2; j += step3)
			{
				Cell *C = getCell(v3 + i + j);
				if (C->status == NOTHING)
				{
					listCells.push_back(C);
				}
				C->status = SOLID;
			}

		for (Vector i; i.length() <= l2; i += step2)
			for (Vector j; j.length() <= l3; j += step3)
			{
				Cell *C = getCell(v0 + i + j);
				if (C->status == NOTHING)
				{
					listCells.push_back(C);
				}
				C->status = SOLID;
			}

		for (Vector i; i.length() <= l2; i += step2)
			for (Vector j; j.length() <= l2; j += step3)
			{
				Cell *C = getCell(v1 + i + j);
				if (C->status == NOTHING)
				{
					listCells.push_back(C);
				}
				C->status = SOLID;
			}
	}
}

//update the grid based on the marker particles
void ParticleSystem::UpdateCells()
{
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{		
		(*iter)->layer = -1;
	}
	for (list<Particle *>::iterator iter = listParticles.begin(); iter != listParticles.end();)
	{
		Cell *pCell = getCell((*iter)->position);
		if (pCell->status == NOTHING)
		{
			if (isInBound(pCell))
			{
				pCell->status = FLUID;
				pCell->layer = 0;
				listCells.push_back(pCell);
			}
		}
		else if (pCell->status != SOLID)	
		{
			pCell->status = FLUID;
			pCell->layer = 0;
		}
		else
		{
			delete(*iter);
			iter = listParticles.erase(iter);
			continue;
		}
		iter++;
	}
	for (int i = 1; i <= 2 || i <= BUFFER; i++)
	{
		for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
		{
			if ((*iter)->status != SOLID && (*iter)->status != NOTHING && (*iter)->layer == i - 1)
			{
				Cell *C = *iter;
				Cell *N;
				int posx = BUFFER + C->x;
				int posy = BUFFER + C->y;
				int posz = BUFFER + C->z;

				N = &grid[posx - 1][posy][posz];
				N->x = C->x - 1;
				N->y = C->y;
				N->z = C->z;
				CreateBuffer(N, i);

				N = &grid[posx + 1][posy][posz];
				N->x = C->x + 1;
				N->y = C->y;
				N->z = C->z;
				CreateBuffer(N, i);

				N = &grid[posx][posy - 1][posz];
				N->x = C->x;
				N->y = C->y - 1;
				N->z = C->z;
				CreateBuffer(N, i);

				N = &grid[posx][posy + 1][posz];
				N->x = C->x;
				N->y = C->y + 1;
				N->z = C->z;
				CreateBuffer(N, i);

				N = &grid[posx][posy][posz - 1];
				N->x = C->x;
				N->y = C->y;
				N->z = C->z - 1;
				CreateBuffer(N, i);

				N = &grid[posx][posy][posz + 1];
				N->x = C->x;
				N->y = C->y;
				N->z = C->z + 1;
				CreateBuffer(N, i);
			}
		}
	}
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end();)
	{
		if ((*iter)->layer == -1)
		{
			Cell *c = *iter;
			memset(c, 0, sizeof(Cell));
			iter = listCells.erase(iter);
		}
		else
		{
			iter++;
		}
	}
}

//apply convection using a backwards particle trace
void ParticleSystem::ApplyConvection()
{
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *g = *iter;
		int posX = BUFFER + g->x;
		int posY = BUFFER + g->y;
		int posZ = BUFFER + g->z;
		if (g->status == FLUID)
		{
			Vector v;
			v = this->traceParticle(g->x * CELL_WIDTH, g->y * CELL_WIDTH + 0.5f, g->z * CELL_WIDTH + 0.5f, deltaTime);
			g->newvelocity.x = this->getVelocity(v.x, v.y, v.z).x;
			v = this->traceParticle(g->x * CELL_WIDTH + 0.5f, g->y * CELL_WIDTH, g->z * CELL_WIDTH + 0.5f, deltaTime);
			g->newvelocity.y = this->getVelocity(v.x, v.y, v.z).y;
			v = this->traceParticle(g->x * CELL_WIDTH + 0.5f, g->y * CELL_WIDTH + 0.5f, g->z * CELL_WIDTH, deltaTime);
			g->newvelocity.z = this->getVelocity(v.x, v.y, v.z).z;
		}
		else if (grid[posX-1][posY][posZ].status == FLUID)
		{
			Vector v;
			g->newvelocity = g->velocity;
			v = this->traceParticle(g->x * CELL_WIDTH, g->y * CELL_WIDTH + 0.5f, g->z * CELL_WIDTH + 0.5f, deltaTime);
			g->newvelocity.x = this->getVelocity(v.x, v.y, v.z).x;
		}
		else if (grid[posX][posY-1][posZ].status == FLUID)
		{
			Vector v;
			g->newvelocity = g->velocity;
			v = this->traceParticle(g->x * CELL_WIDTH + 0.5f, g->y * CELL_WIDTH, g->z * CELL_WIDTH + 0.5f, deltaTime);
			g->newvelocity.y = this->getVelocity(v.x, v.y, v.z).y;
		}
		else if (grid[posX][posY][posZ-1].status == FLUID)
		{
			Vector v;
			g->newvelocity = g->velocity;
			v = this->traceParticle(g->x * CELL_WIDTH + 0.5f, g->y * CELL_WIDTH + 0.5f, g->z * CELL_WIDTH, deltaTime);
			g->newvelocity.z = this->getVelocity(v.x, v.y, v.z).z;
		}
		else
		{
			g->newvelocity = g->velocity;
		}
	}
	maxVelocity = 0.0f;
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *C = *iter;
		float l = C->newvelocity.length();
		if (maxVelocity < l)
		{
			maxVelocity = l;
		}
		C->velocity = C->newvelocity;
	}
}

//apply gravity(external force)
void ParticleSystem::ApplyGravity()
{
	maxVelocity = 0.0f;
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *g = *iter;
		int posX = BUFFER + g->x;
		int posY = BUFFER + g->y;
		int posZ = BUFFER + g->z;
		if (g->status == FLUID || grid[posX][posY-1][posZ].status == FLUID)
		{
			g->velocity.y += deltaTime * GRAVITY;
			float l = g->velocity.length();
			if (l > maxVelocity)
			{
				maxVelocity = l;
			}
		}
	}
}

//apply pressure
void ParticleSystem::ApplyPressure()
{
	vector<Cell *> fluidCells;
	int count = 0;
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *C = *iter;
		if (C->status == FLUID)
		{
			fluidCells.push_back(C);
			C->layer = count;
			count++;
		}
	}
	float *sra = new float[7 * count];
	int*clm = new int[7 * count];
	int *fnz = new int[count + 1];
	int pos = 0;
	count = 0;
	for (vector<Cell *>::iterator iter = fluidCells.begin(); iter != fluidCells.end(); iter++)
	{
		Cell *C = *iter;
		fnz[count] = pos;
		int neighbor = 0;

		int posX = BUFFER + C->x;
		int posY = BUFFER + C->y;
		int posZ = BUFFER + C->z;
		if (grid[posX - 1][posY][posZ].status == FLUID)
		{
			neighbor++;
			sra[pos] = 1.0f;
			clm[pos] = grid[posX - 1][posY][posZ].layer;
			pos++;
		}
		else if (grid[posX - 1][posY][posZ].status == AIR)
		{
			neighbor++;
		}

		if (grid[posX + 1][posY][posZ].status == FLUID)
		{
			neighbor++;
			sra[pos] = 1.0f;
			clm[pos] = grid[posX + 1][posY][posZ].layer;
			pos++;
		}
		else if (grid[posX + 1][posY][posZ].status == AIR)
		{
			neighbor++;
		}

		if (grid[posX][posY - 1][posZ].status == FLUID)
		{
			neighbor++;
			sra[pos] = 1.0f;
			clm[pos] = grid[posX][posY - 1][posZ].layer;
			pos++;
		}
		else if (grid[posX][posY - 1][posZ].status == AIR)
		{
			neighbor++;
		}

		if (grid[posX][posY + 1][posZ].status == FLUID)
		{
			neighbor++;
			sra[pos] = 1.0f;
			clm[pos] = grid[posX][posY + 1][posZ].layer;
			pos++;
		}
		else if (grid[posX][posY + 1][posZ].status == AIR)
		{
			neighbor++;
		}

		if (grid[posX][posY][posZ - 1].status == FLUID)
		{
			neighbor++;
			sra[pos] = 1.0f;
			clm[pos] = grid[posX][posY][posZ - 1].layer;
			pos++;
		}
		else if (grid[posX][posY][posZ - 1].status == AIR)
		{
			neighbor++;
		}

		if (grid[posX][posY][posZ + 1].status == FLUID)
		{
			neighbor++;
			sra[pos] = 1.0f;
			clm[pos] = grid[posX][posY][posZ + 1].layer;
			pos++;
		}
		else if (grid[posX][posY][posZ + 1].status == AIR)
		{
			neighbor++;
		}
		
		sra[pos] = static_cast<float>(-neighbor);
		clm[pos] = count;
		pos++;
		count++;
	}
	fnz[count] = pos;
	float *b = new float[count];
	for (int i = 0; i != count; i++)
	{
		b[i] = divVelocity(fluidCells[i]);		
	}
	float *x = new float[count];
	for (int i = 0; i != count; i++)
	{
		x[i] = 0.0f;		
	}
	PCG(count, sra, clm, fnz, x, b);
	for (int i = 0; i != count; i++)
	{
		fluidCells[i]->pressure = x[i];
	}
	delete []sra;
	delete []clm;
	delete []b;
	delete []fnz;
	delete []x;
	maxVelocity = 0.0f;
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *C = *iter;
		if (C->status == SOLID)
		{
			continue;
		}
		if (C->status == AIR)
		{
			C->pressure = 0;
		}
		C->velocity -= gradPressure(C);
		float l = C->velocity.length();
		if (maxVelocity < l)
		{
			maxVelocity = l;
		}
	}
}

//extrapolate the fluid velocity to the buffer zone
void ParticleSystem::UpdateBufferVelocity()
{
	list<Cell *> nfluidCells;
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *C = *iter;
		if (C->status == FLUID)
		{
			C->layer = 0;
		}
		else
		{
			C->layer = -1;
			nfluidCells.push_back(C);
		}
	}
	for (int i = 1; i <= 2 || i <= BUFFER; i++)
	{
		for (list<Cell *>::iterator iter = nfluidCells.begin(); iter != nfluidCells.end();)
		{
			Cell *C = *iter;
			bool fN = false;
			Cell *N;
			int count = 0;
			Vector sum(0.0f, 0.0f, 0.0f);
			int posX = BUFFER + C->x;
			int posY = BUFFER + C->y;
			int posZ = BUFFER + C->z;
			N = &grid[posX - 1][posY][posZ];
			if (N->layer == i - 1 && N->status != NOTHING)
			{
				fN = true;
				count++;
				sum += N->velocity;
			}
			N = &grid[posX + 1][posY][posZ];
			if (N->layer == i - 1 && N->status != NOTHING)
			{
				fN = true;
				count++;
				sum += N->velocity;
			}
			N = &grid[posX][posY - 1][posZ];
			if (N->layer == i - 1 && N->status != NOTHING)
			{
				fN = true;
				count++;
				sum += N->velocity;
			}
			N = &grid[posX][posY + 1][posZ];
			if (N->layer == i - 1 && N->status != NOTHING)
			{
				fN = true;
				count++;
				sum += N->velocity;
			}
			N = &grid[posX][posY][posZ - 1];
			if (N->layer == i - 1 && N->status != NOTHING)
			{
				fN = true;
				count++;
				sum += N->velocity;
			}
			N = &grid[posX][posY][posZ + 1];
			if (N->layer == i - 1 && N->status != NOTHING)
			{
				fN = true;
				count++;
				sum += N->velocity;
			}
			if (fN)
			{
				if (grid[posX - 1][posY][posZ].status != FLUID)
				{
					C->velocity.x = sum.x / static_cast<float>(count);
				}
				if (grid[posX][posY - 1][posZ].status != FLUID)
				{
					C->velocity.y = sum.y / static_cast<float>(count);
				}
				if (grid[posX][posY][posZ - 1].status != FLUID)
				{
					C->velocity.z = sum.z / static_cast<float>(count);
				}
				C->layer = i;
				iter = nfluidCells.erase(iter);
			}
			else
			{
				iter++;
			}
		}
	}
	for (list<Particle *>::iterator iter = listParticles.begin(); iter != listParticles.end(); iter++)
	{
		Particle *p = *iter;
		p->velocity = getVelocity(p->position.x, p->position.y, p->position.z);
	}
}

//set solid cell velocities
void ParticleSystem::SetSolidCells()
{
	for (list<Cell *>::iterator iter = listCells.begin(); iter != listCells.end(); iter++)
	{
		Cell *C = *iter;
		int posX = BUFFER + C->x;
		int posY = BUFFER + C->y;
		int posZ = BUFFER + C->z;
		if (C->status == SOLID)
		{
			if (grid[posX - 1][posY][posZ].status != SOLID && C->velocity.x < 0)
			{
				//C->velocity.x = - C->velocity.x;
				C->velocity.x = 0;
			}
			if (grid[posX][posY - 1][posZ].status != SOLID && C->velocity.y < 0)
			{
				//C->velocity.y = - C->velocity.y;
				C->velocity.y = 0;
			}
			if (grid[posX][posY][posZ - 1].status != SOLID && C->velocity.z < 0)
			{
				//C->velocity.z = - C->velocity.z;
				C->velocity.z = 0;
			}
		}
		if (C->status != SOLID)
		{
			if (grid[posX - 1][posY][posZ].status == SOLID && C->velocity.x > 0)
			{
				//C->velocity.x = - C->velocity.x;
				C->velocity.x = 0;
			}
			if (grid[posX][posY - 1][posZ].status == SOLID && C->velocity.y > 0)
			{
				//C->velocity.y = - C->velocity.y;
				C->velocity.y = 0;
			}
			if (grid[posX][posY][posZ - 1].status == SOLID && C->velocity.z > 0)
			{
				//C->velocity.z = - C->velocity.z;
				C->velocity.z = 0;
			}
		}
	}
}

//move particles for time t
void ParticleSystem::MoveParticles(float time)
{
	for (list<Particle *>::iterator iter = listParticles.begin(); iter != listParticles.end();)
	{
		Particle *p = *iter;
		Vector v = getVelocity(p->position.x, p->position.y, p->position.z);
		//p->velocity = getVelocity(p->position.x, p->position.y, p->position.z) * -1.0f;
		//p->position -= v * time;

		if (getCell(p->position - v * time)->status != SOLID)
		{
			p->position -= v * time;
		}
		if (getCell(p->position - v * time)->z > 90)
		{
			delete (*iter);
			iter = listParticles.erase(iter);
			continue;
		}

		iter++;
	}
}*/
